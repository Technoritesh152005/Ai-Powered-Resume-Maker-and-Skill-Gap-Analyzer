ðŸ”¥ SCENARIO

User sends request:

POST /upload
FormData:
  resume â†’ file.pdf
  name â†’ Ritesh

Route:

app.post("/upload", handleUpload(uploadResume), controller);
ðŸ§  STEP 1 â€” Express Receives Request

Express creates:

req
res
next

Then it looks at route middleware chain:

handleUpload(uploadResume)

controller

ðŸ§  STEP 2 â€” handleUpload(uploadResume) Runs

Important:

When app started, this already happened:

handleUpload(uploadResume)

This returned a middleware:

(req, res, next) => {
   uploadFunction(req, res, callback)
}

So Express now calls that returned function.

ðŸ§  STEP 3 â€” Inside handleUpload

Now this runs:

uploadFunction(req, res, (err) => {
   ...
});

Here:

uploadFunction = uploadResume

Which came from:

multer(...).single("resume")

So now multer middleware starts running.

ðŸ§  STEP 4 â€” Multer Starts Processing

Multer does internally:

Reads incoming form-data stream

Detects file field

Builds file object

Something like:

file = {
  originalname: "file.pdf",
  mimetype: "application/pdf",
  size: ...
}
ðŸ§  STEP 5 â€” Multer Calls fileFilter

Before saving file, multer checks:

fileFilter(req, file, cb)

It passes:

req â†’ same Express request

file â†’ file metadata

cb â†’ multerâ€™s internal callback

Now your code runs:

if (allowed) {
   cb(null, true);
} else {
   cb(new ApiError(...), false);
}
ðŸ§  CASE A â€” File Valid

You call:

cb(null, true);

Meaning:

No error

Accept file

Multer continues.

ðŸ§  STEP 6 â€” Multer Calls destination

Now multer asks:

destination(req, file, cb)

You respond:

cb(null, uploadDir);

Multer now knows where to save file.

ðŸ§  STEP 7 â€” Multer Calls filename

Multer asks:

filename(req, file, cb)

You respond:

cb(null, "resume-12345.pdf");

Now multer knows final name.

ðŸ§  STEP 8 â€” Multer Saves File

File is written to disk.

Now multer attaches to request:

req.file = { ...file info... }
req.body = { name: "Ritesh" }
ðŸ§  STEP 9 â€” Multer Finishes

Now multer finishes processing and calls the callback you passed:

(err) => { ... }

Since no error:

err = null
ðŸ§  STEP 10 â€” Back To handleUpload

Now this runs:

if (err) {
   next(error)
}

But err is null.

So:

next();
ðŸ§  STEP 11 â€” Controller Runs

Now your controller runs.

Inside controller:

req.file   // available
req.body   // available

You send response:

Upload successful

Done.

âŒ CASE B â€” Invalid File Type

Now different path.

Inside fileFilter:

cb(new ApiError(...), false);
What Happens Now?

Multer receives error

Stops processing

Does NOT save file

Calls your upload callback:

(err) => { ... }

Now:

err = ApiError
Back To handleUpload

Now this runs:

if (err) {
   return next(err);
}

So Express receives error.

Express Error Middleware Runs

Express catches error and sends response:

400 Invalid file type

Controller never runs.